// These diagnostics are ignored because property-based tests often use
// dynamic data generation and mock configurations that may not strictly
// adhere to type safety or immutability rules.
// ignore_for_file: argument_type_not_assignable, must_be_immutable
import 'dart:math';

import 'package:flutter_test/flutter_test.dart';
import 'package:grex/features/payments/data/repositories/supabase_payment_repository.dart';
import 'package:grex/features/payments/domain/entities/payment.dart';
import 'package:grex/features/payments/domain/repositories/payment_repository.dart';
import 'package:mockito/mockito.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

// Mock classes
class MockSupabaseClient extends Mock implements SupabaseClient {}

class MockGoTrueClient extends Mock implements GoTrueClient {}

class MockUser extends Mock implements User {}

class MockPostgrestQueryBuilder extends Mock
    implements PostgrestQueryBuilder<dynamic> {}

class MockPostgrestFilterBuilder extends Mock
    implements PostgrestFilterBuilder<dynamic> {}

/// Property-based test generators for Payment entities
class PaymentTestGenerators {
  static final Random _random = Random();

  /// Generate a random valid amount
  static double generateAmount() {
    // Generate amounts between 0.01 and 1000.00
    return (_random.nextDouble() * 999.99) + 0.01;
  }

  /// Generate a random currency code
  static String generateCurrency() {
    final currencies = ['VND', 'USD', 'EUR', 'GBP', 'JPY'];
    return currencies[_random.nextInt(currencies.length)];
  }

  /// Generate a random user ID
  static String generateUserId() {
    return 'user-${_random.nextInt(10000)}';
  }

  /// Generate a random group ID
  static String generateGroupId() {
    return 'group-${_random.nextInt(10000)}';
  }

  /// Generate a random payment ID
  static String generatePaymentId() {
    return 'payment-${_random.nextInt(10000)}';
  }

  /// Generate a random description
  static String generateDescription() {
    final descriptions = [
      'Dinner payment',
      'Movie ticket reimbursement',
      'Grocery split',
      'Gas money',
      'Coffee payment',
      'Taxi fare',
      'Hotel payment',
      'Concert ticket',
      'Office lunch',
      'Team dinner',
    ];
    return descriptions[_random.nextInt(descriptions.length)];
  }

  /// Generate a random Payment entity for testing
  static Payment generatePayment({
    String? id,
    String? groupId,
    String? payerId,
    String? recipientId,
    double? amount,
    String? currency,
    String? description,
    DateTime? paymentDate,
  }) {
    final generatedPayerId = payerId ?? generateUserId();
    var generatedRecipientId = recipientId ?? generateUserId();

    // Ensure payer and recipient are different
    while (generatedRecipientId == generatedPayerId) {
      generatedRecipientId = generateUserId();
    }

    return Payment(
      id: id ?? generatePaymentId(),
      groupId: groupId ?? generateGroupId(),
      payerId: generatedPayerId,
      payerName: 'User $generatedPayerId',
      recipientId: generatedRecipientId,
      recipientName: 'User $generatedRecipientId',
      amount: amount ?? generateAmount(),
      currency: currency ?? generateCurrency(),
      description: description ?? generateDescription(),
      paymentDate:
          paymentDate ??
          DateTime.now().subtract(Duration(days: _random.nextInt(30))),
      createdAt: DateTime.now(),
    );
  }
}

void main() {
  group('PaymentRepository Property Tests', () {
    late MockSupabaseClient mockSupabaseClient;
    late MockGoTrueClient mockAuth;
    late MockUser mockUser;
    late PaymentRepository repository;

    setUp(() async {
      mockSupabaseClient = MockSupabaseClient();
      mockAuth = MockGoTrueClient();
      mockUser = MockUser();

      // Setup basic mocks
      when(mockSupabaseClient.auth).thenReturn(mockAuth);
      when(mockAuth.currentUser).thenReturn(mockUser);
      when(mockUser.id).thenReturn('test-user-id');

      repository = SupabasePaymentRepository(
        supabaseClient: mockSupabaseClient,
      );
    });

    group('Property 13: Payment creation links payer and recipient', () {
      test(
        'should correctly link payer and recipient for any valid payment',
        () async {
          // Property: For any valid payment data, when a payment is created,
          // it should correctly link the specified payer and recipient

          const iterations = 100;

          for (var i = 0; i < iterations; i++) {
            final payerId = 'payer-$i';
            final recipientId = 'recipient-$i';

            final testPayment = PaymentTestGenerators.generatePayment(
              id: '', // Will be generated by database
              payerId: payerId,
              recipientId: recipientId,
            );

            // Mock group membership checks
            _setupGroupMembershipMock(
              mockSupabaseClient,
              testPayment.groupId,
              'test-user-id',
              true,
            );
            _setupGroupMembershipMock(
              mockSupabaseClient,
              testPayment.groupId,
              payerId,
              true,
            );
            _setupGroupMembershipMock(
              mockSupabaseClient,
              testPayment.groupId,
              recipientId,
              true,
            );

            // Mock successful payment creation
            _setupSuccessfulPaymentCreationMocks(
              mockSupabaseClient,
              testPayment,
            );

            // Act
            final result = await repository.createPayment(testPayment);

            // Assert - Property: Payment should link correct payer and
            // recipient
            expect(
              result.isRight(),
              isTrue,
              reason:
                  'Payment creation should succeed for valid data '
                  '(iteration $i)',
            );

            result.fold(
              (failure) =>
                  fail('Should not fail for valid payment data: $failure'),
              (createdPayment) {
                expect(
                  createdPayment.payerId,
                  equals(payerId),
                  reason: 'Payer should be set correctly (iteration $i)',
                );
                expect(
                  createdPayment.recipientId,
                  equals(recipientId),
                  reason: 'Recipient should be set correctly (iteration $i)',
                );

                // Additional property: Payer and recipient should be different
                expect(
                  createdPayment.payerId,
                  isNot(equals(createdPayment.recipientId)),
                  reason:
                      'Payer and recipient should be different users '
                      '(iteration $i)',
                );

                // Property: Payment should maintain all original data
                expect(
                  createdPayment.amount,
                  equals(testPayment.amount),
                  reason: 'Amount should be preserved (iteration $i)',
                );
                expect(
                  createdPayment.currency,
                  equals(testPayment.currency),
                  reason: 'Currency should be preserved (iteration $i)',
                );
              },
            );
          }
        },
      );

      test(
        'should maintain link consistency across different payment '
        'configurations',
        () async {
          // Property: Regardless of amount, currency, or description,
          // the payer-recipient link should always be correct

          const iterations = 50;

          for (var i = 0; i < iterations; i++) {
            final payerId = 'consistent-payer-$i';
            final recipientId = 'consistent-recipient-$i';

            // Test with different configurations
            final amounts = [0.01, 1.0, 100.0, 1000.0, 9999.99];
            final currencies = ['VND', 'USD', 'EUR'];

            final amount = amounts[i % amounts.length];
            final currency = currencies[i % currencies.length];

            final testPayment = PaymentTestGenerators.generatePayment(
              payerId: payerId,
              recipientId: recipientId,
              amount: amount,
              currency: currency,
            );

            // Mock the same successful creation flow
            _setupGroupMembershipMock(
              mockSupabaseClient,
              testPayment.groupId,
              'test-user-id',
              true,
            );
            _setupGroupMembershipMock(
              mockSupabaseClient,
              testPayment.groupId,
              payerId,
              true,
            );
            _setupGroupMembershipMock(
              mockSupabaseClient,
              testPayment.groupId,
              recipientId,
              true,
            );
            _setupSuccessfulPaymentCreationMocks(
              mockSupabaseClient,
              testPayment,
            );

            // Act
            final result = await repository.createPayment(testPayment);

            // Assert - Property holds regardless of payment configuration
            expect(result.isRight(), isTrue);
            result.fold(
              (failure) => fail('Should not fail: $failure'),
              (createdPayment) {
                expect(
                  createdPayment.payerId,
                  equals(payerId),
                  reason:
                      'Payer link should be consistent regardless of '
                      'configuration (iteration $i)',
                );
                expect(
                  createdPayment.recipientId,
                  equals(recipientId),
                  reason:
                      'Recipient link should be consistent regardless of '
                      'configuration (iteration $i)',
                );
              },
            );
          }
        },
      );

      test('should reject self-payments', () async {
        // Property: Payments where payer and recipient are the same should be
        // rejected

        const iterations = 30;

        for (var i = 0; i < iterations; i++) {
          final userId = 'user-$i';

          final testPayment = PaymentTestGenerators.generatePayment(
            payerId: userId,
            recipientId: userId, // Same as payer
          );

          // Mock group membership
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            'test-user-id',
            true,
          );

          // Act
          final result = await repository.createPayment(testPayment);

          // Assert - Property: Self-payment should be rejected
          expect(
            result.isLeft(),
            isTrue,
            reason: 'Self-payment should be rejected (iteration $i)',
          );

          result.fold(
            (failure) {
              expect(
                failure.toString().toLowerCase(),
                contains('self'),
                reason: 'Should return self-payment error (iteration $i)',
              );
            },
            (success) => fail('Should not succeed with self-payment'),
          );
        }
      });
    });

    group('Property 15: Payment creation updates both balances', () {
      test('should affect balances of both payer and recipient', () async {
        // Property: When a payment is created, it should affect the balances
        // of both the payer and recipient in the group

        const iterations = 50;

        for (var i = 0; i < iterations; i++) {
          final testPayment = PaymentTestGenerators.generatePayment();

          // Mock group membership checks
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            'test-user-id',
            true,
          );
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            testPayment.payerId,
            true,
          );
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            testPayment.recipientId,
            true,
          );

          // Mock successful payment creation
          _setupSuccessfulPaymentCreationMocks(mockSupabaseClient, testPayment);

          // Act
          final result = await repository.createPayment(testPayment);

          // Assert - Property: Payment creation should succeed
          expect(
            result.isRight(),
            isTrue,
            reason: 'Payment creation should succeed (iteration $i)',
          );

          result.fold(
            (failure) => fail('Should not fail: $failure'),
            (createdPayment) {
              // Property: Payment should have positive amount
              expect(
                createdPayment.amount,
                greaterThan(0),
                reason: 'Payment should have positive amount (iteration $i)',
              );

              // Property: Payment should link two different users
              expect(
                createdPayment.payerId,
                isNot(equals(createdPayment.recipientId)),
                reason: 'Payment should link different users (iteration $i)',
              );

              // Property: Payment should have valid timestamps
              expect(
                createdPayment.paymentDate,
                isNotNull,
                reason: 'Payment should have valid payment date (iteration $i)',
              );
              expect(
                createdPayment.createdAt,
                isNotNull,
                reason:
                    'Payment should have valid created timestamp '
                    '(iteration $i)',
              );
            },
          );
        }
      });

      test(
        'should validate participant membership before affecting balances',
        () async {
          // Property: Only payments between group members should be allowed
          // and affect balances

          const iterations = 30;

          for (var i = 0; i < iterations; i++) {
            final testPayment = PaymentTestGenerators.generatePayment();

            // Mock current user membership
            _setupGroupMembershipMock(
              mockSupabaseClient,
              testPayment.groupId,
              'test-user-id',
              true,
            );

            // Mock payer membership (valid)
            _setupGroupMembershipMock(
              mockSupabaseClient,
              testPayment.groupId,
              testPayment.payerId,
              true,
            );

            // Mock recipient NOT being a member
            _setupGroupMembershipMock(
              mockSupabaseClient,
              testPayment.groupId,
              testPayment.recipientId,
              false,
            );

            // Act
            final result = await repository.createPayment(testPayment);

            // Assert - Property: Should reject payment with non-member
            // recipient
            expect(
              result.isLeft(),
              isTrue,
              reason:
                  'Should reject payment with non-member recipient '
                  '(iteration $i)',
            );

            result.fold(
              (failure) {
                expect(
                  failure.toString().toLowerCase(),
                  anyOf([
                    contains('participant'),
                    contains('member'),
                    contains('group'),
                  ]),
                  reason:
                      'Should return membership-related error (iteration $i)',
                );
              },
              (success) => fail('Should not succeed with non-member recipient'),
            );
          }
        },
      );

      test('should handle different currencies correctly', () async {
        // Property: Payments should preserve currency information and
        // handle different currencies appropriately

        const iterations = 30;
        final currencies = ['VND', 'USD', 'EUR', 'GBP', 'JPY'];

        for (var i = 0; i < iterations; i++) {
          final currency = currencies[i % currencies.length];

          final testPayment = PaymentTestGenerators.generatePayment(
            currency: currency,
          );

          // Mock group membership checks
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            'test-user-id',
            true,
          );
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            testPayment.payerId,
            true,
          );
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            testPayment.recipientId,
            true,
          );

          // Mock successful creation
          _setupSuccessfulPaymentCreationMocks(mockSupabaseClient, testPayment);

          // Act
          final result = await repository.createPayment(testPayment);

          // Assert - Property: Currency should be preserved
          expect(result.isRight(), isTrue);
          result.fold(
            (failure) => fail('Should not fail for valid currency: $failure'),
            (createdPayment) {
              expect(
                createdPayment.currency,
                equals(currency),
                reason:
                    'Currency should be preserved '
                    '(iteration $i, currency: $currency)',
              );
            },
          );
        }
      });
    });

    group('Property 14: Payment validation enforces positive amounts', () {
      test('should accept all payments with positive amounts', () async {
        // Property: For any payment with a positive amount, validation should
        // succeed

        const iterations = 100;

        for (var i = 0; i < iterations; i++) {
          // Generate positive amounts with various scales
          final amounts = [
            0.01, // Minimum positive
            Random().nextDouble() * 10, // Small amounts
            Random().nextDouble() * 100 + 10, // Medium amounts
            Random().nextDouble() * 1000 + 100, // Large amounts
            9999.99, // Maximum reasonable amount
          ];

          final amount = amounts[i % amounts.length];
          final testPayment = PaymentTestGenerators.generatePayment(
            amount: amount,
          );

          // Mock group membership checks
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            'test-user-id',
            true,
          );
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            testPayment.payerId,
            true,
          );
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            testPayment.recipientId,
            true,
          );

          // Act
          final result = await repository.validatePayment(testPayment);

          // Assert - Property: Positive amounts should be valid
          expect(
            result.isRight(),
            isTrue,
            reason:
                'Positive amount should be valid '
                '(iteration $i, amount: $amount)',
          );

          result.fold(
            (failure) => fail('Should not fail for positive amount: $failure'),
            (isValid) {
              expect(
                isValid,
                isTrue,
                reason:
                    'Validation should return true for positive amount '
                    '(iteration $i)',
              );
            },
          );
        }
      });

      test('should reject all payments with non-positive amounts', () async {
        // Property: For any payment with zero or negative amount, validation
        // should fail

        const iterations = 50;

        for (var i = 0; i < iterations; i++) {
          // Generate non-positive amounts
          final invalidAmounts = [
            0.0, // Zero
            -0.01, // Small negative
            -Random().nextDouble() * 10, // Random negative
            -100.0, // Large negative
            -9999.99, // Very large negative
          ];

          final amount = invalidAmounts[i % invalidAmounts.length];
          final testPayment = PaymentTestGenerators.generatePayment(
            amount: amount,
          );

          // Mock group membership checks
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            'test-user-id',
            true,
          );
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            testPayment.payerId,
            true,
          );
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            testPayment.recipientId,
            true,
          );

          // Act
          final result = await repository.validatePayment(testPayment);

          // Assert - Property: Non-positive amounts should be invalid
          expect(
            result.isLeft(),
            isTrue,
            reason:
                'Non-positive amount should be invalid '
                '(iteration $i, amount: $amount)',
          );

          result.fold(
            (failure) {
              expect(
                failure.toString().toLowerCase(),
                contains('amount'),
                reason: 'Should return amount-related error (iteration $i)',
              );
            },
            (success) => fail('Should not succeed with non-positive amount'),
          );
        }
      });

      test('should handle edge cases around zero correctly', () async {
        // Property: Amounts very close to zero should be handled correctly

        const iterations = 30;

        for (var i = 0; i < iterations; i++) {
          // Test edge cases around zero
          final edgeCases = [
            0.001, // Very small positive
            0.01, // Minimum currency unit
            -0.001, // Very small negative
            double.minPositive, // Smallest positive double
          ];

          final amount = edgeCases[i % edgeCases.length];
          final testPayment = PaymentTestGenerators.generatePayment(
            amount: amount,
          );

          // Mock group membership checks
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            'test-user-id',
            true,
          );
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            testPayment.payerId,
            true,
          );
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            testPayment.recipientId,
            true,
          );

          // Act
          final result = await repository.validatePayment(testPayment);

          // Assert - Property: Validation should be consistent with sign
          if (amount > 0) {
            expect(
              result.isRight(),
              isTrue,
              reason:
                  'Positive edge case should be valid '
                  '(iteration $i, amount: $amount)',
            );
          } else {
            expect(
              result.isLeft(),
              isTrue,
              reason:
                  'Non-positive edge case should be invalid '
                  '(iteration $i, amount: $amount)',
            );
          }
        }
      });

      test('should validate amount precision correctly', () async {
        // Property: Amounts with reasonable precision should be accepted

        const iterations = 50;

        for (var i = 0; i < iterations; i++) {
          // Generate amounts with different precision levels
          final baseAmount = Random().nextDouble() * 100 + 1;
          final precisionLevels = [
            double.parse(baseAmount.toStringAsFixed(0)), // No decimals
            double.parse(baseAmount.toStringAsFixed(1)), // 1 decimal
            double.parse(
              baseAmount.toStringAsFixed(2),
            ), // 2 decimals (currency standard)
            double.parse(baseAmount.toStringAsFixed(3)), // 3 decimals
          ];

          final amount = precisionLevels[i % precisionLevels.length];
          final testPayment = PaymentTestGenerators.generatePayment(
            amount: amount,
          );

          // Mock group membership checks
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            'test-user-id',
            true,
          );
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            testPayment.payerId,
            true,
          );
          _setupGroupMembershipMock(
            mockSupabaseClient,
            testPayment.groupId,
            testPayment.recipientId,
            true,
          );

          // Act
          final result = await repository.validatePayment(testPayment);

          // Assert - Property: All positive amounts with reasonable precision
          // should be valid
          expect(
            result.isRight(),
            isTrue,
            reason:
                'Amount with reasonable precision should be valid '
                '(iteration $i, amount: $amount)',
          );

          result.fold(
            (failure) =>
                fail('Should not fail for reasonable precision: $failure'),
            (isValid) {
              expect(
                isValid,
                isTrue,
                reason:
                    'Validation should succeed for reasonable precision '
                    '(iteration $i)',
              );
            },
          );
        }
      });

      test('should validate currency constraints', () async {
        // Property: Payments should have valid currency codes

        const iterations = 30;

        for (var i = 0; i < iterations; i++) {
          final validCurrencies = ['VND', 'USD', 'EUR', 'GBP', 'JPY'];
          final invalidCurrencies = ['', '   ', 'INVALID', '123', 'X'];

          // Test valid currencies
          final validCurrency = validCurrencies[i % validCurrencies.length];
          final validPayment = PaymentTestGenerators.generatePayment(
            currency: validCurrency,
          );

          // Mock group membership checks for valid payment
          _setupGroupMembershipMock(
            mockSupabaseClient,
            validPayment.groupId,
            'test-user-id',
            true,
          );
          _setupGroupMembershipMock(
            mockSupabaseClient,
            validPayment.groupId,
            validPayment.payerId,
            true,
          );
          _setupGroupMembershipMock(
            mockSupabaseClient,
            validPayment.groupId,
            validPayment.recipientId,
            true,
          );

          // Act - valid currency
          final validResult = await repository.validatePayment(validPayment);

          // Assert - valid currency should pass
          expect(
            validResult.isRight(),
            isTrue,
            reason:
                'Valid currency should pass validation '
                '(iteration $i, currency: $validCurrency)',
          );

          // Test invalid currencies
          if (i < invalidCurrencies.length) {
            final invalidCurrency = invalidCurrencies[i];
            final invalidPayment = PaymentTestGenerators.generatePayment(
              currency: invalidCurrency,
            );

            // Act - invalid currency (should fail during creation, not
            // validation)
            final createResult = await repository.createPayment(invalidPayment);

            // Assert - invalid currency should be rejected
            expect(
              createResult.isLeft(),
              isTrue,
              reason:
                  'Invalid currency should be rejected '
                  '(iteration $i, currency: "$invalidCurrency")',
            );
          }
        }
      });
    });

    group('Property 17: Payment deletion recalculates balances', () {
      test(
        'should trigger balance recalculation when payment is deleted',
        () async {
          // Property: When a payment is deleted, it should trigger balance
          // recalculation for all affected participants

          const iterations = 50;

          for (var i = 0; i < iterations; i++) {
            final paymentId = 'payment-$i';
            final testPayment = PaymentTestGenerators.generatePayment(
              id: paymentId,
            );

            // Mock permission check (user can delete)
            _setupPaymentPermissionMock(
              mockSupabaseClient,
              paymentId,
              'delete',
              true,
              testPayment,
            );

            // Mock successful deletion
            _setupSuccessfulPaymentDeletionMocks(mockSupabaseClient, paymentId);

            // Track if balance-related operations are triggered
            var balanceOperationTriggered = false;

            // Mock balance calculation function call (would be triggered by
            // database triggers)
            when(
              mockSupabaseClient.rpc<List<dynamic>>(
                'calculate_group_balances',
                params: anyNamed('params'),
              ),
            ).thenAnswer((_) async {
              balanceOperationTriggered = true;
              return [];
            });

            // Act
            final result = await repository.deletePayment(paymentId);

            // Assert - Property: Deletion should succeed and trigger balance
            // recalculation
            expect(
              result.isRight(),
              isTrue,
              reason: 'Payment deletion should succeed (iteration $i)',
            );

            result.fold(
              (failure) => fail('Should not fail for valid deletion: $failure'),
              (_) {
                // Property: Deletion should complete successfully
                // (In real implementation, this would trigger database triggers
                // that recalculate balances)
                expect(
                  balanceOperationTriggered,
                  isTrue,
                  reason:
                      'Balance recalculation should be triggered '
                      '(iteration $i)',
                );
              },
            );
          }
        },
      );

      test('should validate permissions before allowing deletion', () async {
        // Property: Only users with appropriate permissions should be able
        // to delete payments

        const iterations = 30;

        for (var i = 0; i < iterations; i++) {
          final paymentId = 'payment-$i';
          final testPayment = PaymentTestGenerators.generatePayment(
            id: paymentId,
          );

          // Mock permission check (user cannot delete)
          _setupPaymentPermissionMock(
            mockSupabaseClient,
            paymentId,
            'delete',
            false,
            testPayment,
          );

          // Act
          final result = await repository.deletePayment(paymentId);

          // Assert - Property: Should reject unauthorized deletions
          expect(
            result.isLeft(),
            isTrue,
            reason: 'Should reject unauthorized deletion (iteration $i)',
          );

          result.fold(
            (failure) {
              expect(
                failure.toString().toLowerCase(),
                contains('permission'),
                reason: 'Should return permission error (iteration $i)',
              );
            },
            (success) => fail('Should not succeed without permission'),
          );
        }
      });

      test('should handle deletion of non-existent payments', () async {
        // Property: Attempting to delete non-existent payments should fail
        // gracefully

        const iterations = 20;

        for (var i = 0; i < iterations; i++) {
          final nonExistentPaymentId = 'non-existent-payment-$i';

          // Mock payment not found
          _setupPaymentNotFoundMock(mockSupabaseClient, nonExistentPaymentId);

          // Act
          final result = await repository.deletePayment(nonExistentPaymentId);

          // Assert - Property: Should fail with appropriate error
          expect(
            result.isLeft(),
            isTrue,
            reason: 'Should fail for non-existent payment (iteration $i)',
          );

          result.fold(
            (failure) {
              expect(
                failure.toString().toLowerCase(),
                anyOf([
                  contains('not found'),
                  contains('permission'),
                ]),
                reason: 'Should return appropriate error (iteration $i)',
              );
            },
            (success) => fail('Should not succeed for non-existent payment'),
          );
        }
      });

      test(
        'should allow payers and recipients to delete their payments',
        () async {
          // Property: Both payers and recipients should be able to delete
          // payments they are involved in

          const iterations = 40;

          for (var i = 0; i < iterations; i++) {
            final paymentId = 'payment-$i';
            final testPayment = PaymentTestGenerators.generatePayment(
              id: paymentId,
            );

            // Test both payer and recipient permissions
            final isPayerTest = i.isEven;
            final userId = isPayerTest
                ? testPayment.payerId
                : testPayment.recipientId;

            // Mock permission check (user is involved in payment)
            _setupPaymentPermissionMockForUser(
              mockSupabaseClient,
              paymentId,
              'delete',
              userId,
              testPayment,
            );

            // Mock successful deletion
            _setupSuccessfulPaymentDeletionMocks(mockSupabaseClient, paymentId);

            // Act
            final result = await repository.deletePayment(paymentId);

            // Assert - Property: Involved users should be able to delete
            expect(
              result.isRight(),
              isTrue,
              reason:
                  '${isPayerTest ? 'Payer' : 'Recipient'} should be able to '
                  'delete payment (iteration $i)',
            );
          }
        },
      );

      test('should prevent deletion by uninvolved users', () async {
        // Property: Users not involved in a payment should not be able to
        // delete it (unless they are administrators)

        const iterations = 30;

        for (var i = 0; i < iterations; i++) {
          final paymentId = 'payment-$i';
          final testPayment = PaymentTestGenerators.generatePayment(
            id: paymentId,
          );
          final uninvolvedUserId = 'uninvolved-user-$i';

          // Ensure uninvolved user is different from payer and recipient
          while (uninvolvedUserId == testPayment.payerId ||
              uninvolvedUserId == testPayment.recipientId) {
            // This loop ensures we have a truly uninvolved user
            break; // In practice, the generated IDs are different enough
          }

          // Mock permission check (user is not involved and not admin)
          _setupPaymentPermissionMockForUser(
            mockSupabaseClient,
            paymentId,
            'delete',
            uninvolvedUserId,
            testPayment,
          );

          // Act
          final result = await repository.deletePayment(paymentId);

          // Assert - Property: Uninvolved users should not be able to delete
          expect(
            result.isLeft(),
            isTrue,
            reason:
                'Uninvolved user should not be able to delete payment '
                '(iteration $i)',
          );

          result.fold(
            (failure) {
              expect(
                failure.toString().toLowerCase(),
                contains('permission'),
                reason:
                    'Should return permission error for uninvolved user '
                    '(iteration $i)',
              );
            },
            (success) => fail('Should not succeed for uninvolved user'),
          );
        }
      });
    });
  });
}

/// Helper function to setup payment permission mocks
void _setupPaymentPermissionMock(
  MockSupabaseClient mockClient,
  String paymentId,
  String action,
  bool hasPermission,
  Payment testPayment,
) {
  // Mock payment details lookup
  final mockPaymentQueryBuilder = MockPostgrestQueryBuilder();
  final mockPaymentFilterBuilder = MockPostgrestFilterBuilder();
  when(mockClient.from('payments')).thenReturn(mockPaymentQueryBuilder);
  when(
    mockPaymentQueryBuilder.select('payer_id, recipient_id, group_id'),
  ).thenReturn(mockPaymentFilterBuilder);
  when(
    mockPaymentFilterBuilder.eq('id', paymentId),
  ).thenReturn(mockPaymentFilterBuilder);
  when(mockPaymentFilterBuilder.maybeSingle()).thenAnswer(
    (_) async => {
      'payer_id': testPayment.payerId,
      'recipient_id': testPayment.recipientId,
      'group_id': testPayment.groupId,
    },
  );

  // Mock group member role lookup
  final mockMemberQueryBuilder = MockPostgrestQueryBuilder();
  final mockMemberFilterBuilder = MockPostgrestFilterBuilder();
  when(mockClient.from('group_members')).thenReturn(mockMemberQueryBuilder);
  when(
    mockMemberQueryBuilder.select('role'),
  ).thenReturn(mockMemberFilterBuilder);
  when(
    mockMemberFilterBuilder.eq('group_id', testPayment.groupId),
  ).thenReturn(mockMemberFilterBuilder);
  when(
    mockMemberFilterBuilder.eq('user_id', 'test-user-id'),
  ).thenReturn(mockMemberFilterBuilder);
  when(mockMemberFilterBuilder.maybeSingle()).thenAnswer(
    (_) async => hasPermission ? {'role': 'administrator'} : {'role': 'editor'},
  );
}

/// Helper function to setup payment permission mocks for specific user
void _setupPaymentPermissionMockForUser(
  MockSupabaseClient mockClient,
  String paymentId,
  String action,
  String userId,
  Payment testPayment, {
  bool isAdmin = false,
}) {
  // Mock payment details lookup
  final mockPaymentQueryBuilder = MockPostgrestQueryBuilder();
  final mockPaymentFilterBuilder = MockPostgrestFilterBuilder();
  when(mockClient.from('payments')).thenReturn(mockPaymentQueryBuilder);
  when(
    mockPaymentQueryBuilder.select('payer_id, recipient_id, group_id'),
  ).thenReturn(mockPaymentFilterBuilder);
  when(
    mockPaymentFilterBuilder.eq('id', paymentId),
  ).thenReturn(mockPaymentFilterBuilder);
  when(mockPaymentFilterBuilder.maybeSingle()).thenAnswer(
    (_) async => {
      'payer_id': testPayment.payerId,
      'recipient_id': testPayment.recipientId,
      'group_id': testPayment.groupId,
    },
  );

  // Mock group member role lookup if user is not involved in payment
  if (userId != testPayment.payerId && userId != testPayment.recipientId) {
    final mockMemberQueryBuilder = MockPostgrestQueryBuilder();
    final mockMemberFilterBuilder = MockPostgrestFilterBuilder();
    when(mockClient.from('group_members')).thenReturn(mockMemberQueryBuilder);
    when(
      mockMemberQueryBuilder.select('role'),
    ).thenReturn(mockMemberFilterBuilder);
    when(
      mockMemberFilterBuilder.eq('group_id', testPayment.groupId),
    ).thenReturn(mockMemberFilterBuilder);
    when(
      mockMemberFilterBuilder.eq('user_id', userId),
    ).thenReturn(mockMemberFilterBuilder);
    when(mockMemberFilterBuilder.maybeSingle()).thenAnswer(
      (_) async => isAdmin ? {'role': 'administrator'} : {'role': 'editor'},
    );
  }
}

/// Helper function to setup payment not found mocks
void _setupPaymentNotFoundMock(
  MockSupabaseClient mockClient,
  String paymentId,
) {
  final mockPaymentQueryBuilder = MockPostgrestQueryBuilder();
  final mockFilterBuilder = MockPostgrestFilterBuilder();
  when(mockClient.from('payments')).thenReturn(mockPaymentQueryBuilder);
  when(
    mockPaymentQueryBuilder.select('payer_id, recipient_id, group_id'),
  ).thenReturn(mockFilterBuilder);
  when(mockFilterBuilder.eq('id', paymentId)).thenReturn(mockFilterBuilder);
  when(mockFilterBuilder.maybeSingle()).thenAnswer((_) async => null);
}

/// Helper function to setup successful payment deletion mocks
void _setupSuccessfulPaymentDeletionMocks(
  MockSupabaseClient mockClient,
  String paymentId,
) {
  final mockDeleteQueryBuilder = MockPostgrestQueryBuilder();
  final mockFilterBuilder = MockPostgrestFilterBuilder();
  when(mockClient.from('payments')).thenReturn(mockDeleteQueryBuilder);
  when(mockDeleteQueryBuilder.delete()).thenReturn(mockFilterBuilder);
  when(mockFilterBuilder.eq('id', paymentId)).thenAnswer((_) async => {});
}

/// Helper function to setup group membership mocks
void _setupGroupMembershipMock(
  MockSupabaseClient mockClient,
  String groupId,
  String userId,
  bool isMember,
) {
  final mockQueryBuilder = MockPostgrestQueryBuilder();
  final mockFilterBuilder = MockPostgrestFilterBuilder();
  when(mockClient.from('group_members')).thenReturn(mockQueryBuilder);
  when(mockQueryBuilder.select('id')).thenReturn(mockFilterBuilder);
  when(mockFilterBuilder.eq('group_id', groupId)).thenReturn(mockFilterBuilder);
  when(mockFilterBuilder.eq('user_id', userId)).thenReturn(mockFilterBuilder);
  when(
    mockFilterBuilder.maybeSingle(),
  ).thenAnswer((_) async => isMember ? {'id': 'member-id'} : null);
}

/// Helper function to setup successful payment creation mocks
void _setupSuccessfulPaymentCreationMocks(
  MockSupabaseClient mockClient,
  Payment testPayment,
) {
  // Mock payment insertion
  final mockPaymentQueryBuilder = MockPostgrestQueryBuilder();
  final mockPaymentFilterBuilder = MockPostgrestFilterBuilder();

  when(mockClient.from('payments')).thenReturn(mockPaymentQueryBuilder);
  when(
    mockPaymentQueryBuilder.insert(any),
  ).thenReturn(mockPaymentFilterBuilder);
  when(mockPaymentFilterBuilder.select()).thenReturn(mockPaymentFilterBuilder);
  when(mockPaymentFilterBuilder.single()).thenAnswer(
    (_) async => {
      'id': 'generated-payment-id',
      'group_id': testPayment.groupId,
      'payer_id': testPayment.payerId,
      'recipient_id': testPayment.recipientId,
      'amount': testPayment.amount,
      'currency': testPayment.currency,
      'description': testPayment.description,
      'payment_date': testPayment.paymentDate.toIso8601String(),
      'created_at': testPayment.createdAt.toIso8601String(),
    },
  );

  // Mock getPaymentById for final result
  final mockGetQueryBuilder = MockPostgrestQueryBuilder();
  final mockGetFilterBuilder = MockPostgrestFilterBuilder();
  when(mockClient.from('payments')).thenReturn(mockGetQueryBuilder);
  when(mockGetQueryBuilder.select()).thenReturn(mockGetFilterBuilder);
  when(
    mockGetFilterBuilder.eq('id', 'generated-payment-id'),
  ).thenReturn(mockGetFilterBuilder);
  when(mockGetFilterBuilder.single()).thenAnswer(
    (_) async => {
      'id': 'generated-payment-id',
      'group_id': testPayment.groupId,
      'payer_id': testPayment.payerId,
      'recipient_id': testPayment.recipientId,
      'amount': testPayment.amount,
      'currency': testPayment.currency,
      'description': testPayment.description,
      'payment_date': testPayment.paymentDate.toIso8601String(),
      'created_at': testPayment.createdAt.toIso8601String(),
    },
  );
}
