import 'package:grex/features/groups/data/models/group_member_model.dart';
import 'package:grex/features/groups/domain/entities/group.dart';
import 'package:grex/features/groups/domain/entities/group_member.dart';
import 'package:grex/features/groups/domain/entities/member_role.dart';

/// Data model for Group that extends the domain entity
/// Provides additional functionality for data layer operations
class GroupModel extends Group {
  /// Creates a [GroupModel] instance
  const GroupModel({
    required super.id,
    required super.name,
    required super.currency,
    required super.creatorId,
    required super.members,
    required super.createdAt,
    required super.updatedAt,
    super.currentUserRole,
  });

  /// Create from JSON with enhanced error handling
  factory GroupModel.fromJson(Map<String, dynamic> json) {
    try {
      // Handle members from joined query
      final membersData = json['group_members'] as List<dynamic>? ?? [];
      final members = membersData
          .map(
            (memberJson) =>
                GroupMemberModel.fromJson(memberJson as Map<String, dynamic>),
          )
          .cast<GroupMember>()
          .toList();

      return GroupModel(
        id: json['id'] as String,
        name: json['name'] as String,
        currency: json['currency'] as String,
        creatorId: json['creator_id'] as String,
        members: members,
        createdAt: DateTime.parse(json['created_at'] as String),
        updatedAt: DateTime.parse(json['updated_at'] as String),
      );
    } catch (e) {
      throw FormatException('Failed to parse GroupModel from JSON: $e');
    }
  }

  /// Create a new group for insertion with current timestamp
  factory GroupModel.create({
    required String name,
    required String currency,
    required String creatorId,
  }) {
    final now = DateTime.now();
    return GroupModel(
      id: '', // Will be generated by database
      name: name,
      currency: currency,
      creatorId: creatorId,
      members: const [], // Members will be added separately
      createdAt: now,
      updatedAt: now,
    );
  }

  /// Create from domain entity
  factory GroupModel.fromEntity(Group entity) {
    return GroupModel(
      id: entity.id,
      name: entity.name,
      currency: entity.currency,
      creatorId: entity.creatorId,
      members: entity.members,
      createdAt: entity.createdAt,
      updatedAt: entity.updatedAt,
    );
  }

  /// Convert to domain entity
  Group toEntity() {
    return Group(
      id: id,
      name: name,
      currency: currency,
      creatorId: creatorId,
      members: members,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }

  /// Convert to JSON for database operations
  @override
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'currency': currency,
      'creator_id': creatorId,
      'created_at': createdAt.toIso8601String(),
      'updated_at': updatedAt.toIso8601String(),
    };
  }

  /// Create JSON for database insertion (without id and timestamps for
  /// auto-generation)
  Map<String, dynamic> toInsertJson() {
    return {
      'name': name,
      'currency': currency,
      'creator_id': creatorId,
    };
  }

  /// Create JSON for database update (only updatable fields)
  Map<String, dynamic> toUpdateJson() {
    return {
      'name': name,
      'currency': currency,
      'updated_at': DateTime.now().toIso8601String(),
    };
  }

  /// Create a copy with updated fields
  @override
  GroupModel copyWith({
    String? id,
    String? name,
    String? currency,
    String? creatorId,
    List<GroupMember>? members,
    DateTime? createdAt,
    DateTime? updatedAt,
    MemberRole? currentUserRole,
  }) {
    return GroupModel(
      id: id ?? this.id,
      name: name ?? this.name,
      currency: currency ?? this.currency,
      creatorId: creatorId ?? this.creatorId,
      members: members ?? this.members,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      currentUserRole: currentUserRole ?? this.currentUserRole,
    );
  }

  /// Update the group with new timestamp
  GroupModel update({
    String? name,
    String? currency,
  }) {
    return copyWith(
      name: name ?? this.name,
      currency: currency ?? this.currency,
      updatedAt: DateTime.now(),
    );
  }
}
