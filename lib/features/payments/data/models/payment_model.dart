import 'package:grex/features/payments/domain/entities/payment.dart';

/// Data model for Payment that extends the domain entity
/// Provides additional functionality for data layer operations
class PaymentModel extends Payment {
  /// Creates a [PaymentModel] instance
  const PaymentModel({
    required super.id,
    required super.groupId,
    required super.payerId,
    required super.payerName,
    required super.recipientId,
    required super.recipientName,
    required super.amount,
    required super.currency,
    required super.paymentDate,
    required super.createdAt,
    super.description,
  });

  /// Create from JSON with enhanced error handling
  factory PaymentModel.fromJson(Map<String, dynamic> json) {
    try {
      return PaymentModel(
        id: json['id'] as String,
        groupId: json['group_id'] as String,
        payerId: json['payer_id'] as String,
        payerName: json['payer_name'] as String,
        recipientId: json['recipient_id'] as String,
        recipientName: json['recipient_name'] as String,
        amount: (json['amount'] as num).toDouble(),
        currency: json['currency'] as String,
        description: json['description'] as String?,
        paymentDate: DateTime.parse(json['payment_date'] as String),
        createdAt: DateTime.parse(json['created_at'] as String),
      );
    } catch (e) {
      throw FormatException('Failed to parse PaymentModel from JSON: $e');
    }
  }

  /// Create a new payment for insertion with current timestamp
  factory PaymentModel.create({
    required String groupId,
    required String payerId,
    required String payerName,
    required String recipientId,
    required String recipientName,
    required double amount,
    required String currency,
    required DateTime paymentDate,
    String? description,
  }) {
    return PaymentModel(
      id: '', // Will be generated by database
      groupId: groupId,
      payerId: payerId,
      payerName: payerName,
      recipientId: recipientId,
      recipientName: recipientName,
      amount: amount,
      currency: currency,
      description: description,
      paymentDate: paymentDate,
      createdAt: DateTime.now(),
    );
  }

  /// Create from domain entity
  factory PaymentModel.fromEntity(Payment entity) {
    return PaymentModel(
      id: entity.id,
      groupId: entity.groupId,
      payerId: entity.payerId,
      payerName: entity.payerName,
      recipientId: entity.recipientId,
      recipientName: entity.recipientName,
      amount: entity.amount,
      currency: entity.currency,
      description: entity.description,
      paymentDate: entity.paymentDate,
      createdAt: entity.createdAt,
    );
  }

  /// Convert to domain entity
  Payment toEntity() {
    return Payment(
      id: id,
      groupId: groupId,
      payerId: payerId,
      payerName: payerName,
      recipientId: recipientId,
      recipientName: recipientName,
      amount: amount,
      currency: currency,
      description: description,
      paymentDate: paymentDate,
      createdAt: createdAt,
    );
  }

  /// Convert to JSON for database operations
  @override
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'group_id': groupId,
      'payer_id': payerId,
      'payer_name': payerName,
      'recipient_id': recipientId,
      'recipient_name': recipientName,
      'amount': amount,
      'currency': currency,
      'description': description,
      'payment_date': paymentDate.toIso8601String(),
      'created_at': createdAt.toIso8601String(),
    };
  }

  /// Create JSON for database insertion (without id and created_at for
  /// auto-generation)
  Map<String, dynamic> toInsertJson() {
    return {
      'group_id': groupId,
      'payer_id': payerId,
      'payer_name': payerName,
      'recipient_id': recipientId,
      'recipient_name': recipientName,
      'amount': amount,
      'currency': currency,
      'description': description,
      'payment_date': paymentDate.toIso8601String(),
    };
  }

  /// Create a copy with updated fields
  @override
  PaymentModel copyWith({
    String? id,
    String? groupId,
    String? payerId,
    String? payerName,
    String? recipientId,
    String? recipientName,
    double? amount,
    String? currency,
    String? description,
    DateTime? paymentDate,
    DateTime? createdAt,
  }) {
    return PaymentModel(
      id: id ?? this.id,
      groupId: groupId ?? this.groupId,
      payerId: payerId ?? this.payerId,
      payerName: payerName ?? this.payerName,
      recipientId: recipientId ?? this.recipientId,
      recipientName: recipientName ?? this.recipientName,
      amount: amount ?? this.amount,
      currency: currency ?? this.currency,
      description: description ?? this.description,
      paymentDate: paymentDate ?? this.paymentDate,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  /// Validate payment with enhanced business rules
  List<String> validatePayment() {
    final errors = <String>[];

    if (!isValidAmount) {
      errors.add('Payment amount must be positive');
    }

    if (!isNotSelfPayment) {
      errors.add('Cannot make payment to yourself');
    }

    if (amount > 1000000) {
      errors.add('Payment amount exceeds reasonable limit');
    }

    if (payerName.trim().isEmpty) {
      errors.add('Payer name cannot be empty');
    }

    if (recipientName.trim().isEmpty) {
      errors.add('Recipient name cannot be empty');
    }

    if (currency.trim().isEmpty) {
      errors.add('Currency cannot be empty');
    }

    return errors;
  }

  /// Check if payment is valid for creation
  bool get isValidForCreation {
    return validatePayment().isEmpty;
  }
}
