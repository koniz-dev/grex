import 'package:grex/features/expenses/data/models/expense_participant_model.dart';
import 'package:grex/features/expenses/domain/entities/expense.dart';
import 'package:grex/features/expenses/domain/entities/expense_participant.dart';

/// Data model for Expense that extends the domain entity
/// Provides additional functionality for data layer operations
class ExpenseModel extends Expense {
  /// Creates an [ExpenseModel] instance
  const ExpenseModel({
    required super.id,
    required super.groupId,
    required super.payerId,
    required super.payerName,
    required super.amount,
    required super.currency,
    required super.description,
    required super.expenseDate,
    required super.participants,
    required super.createdAt,
    required super.updatedAt,
    super.category,
  });

  /// Create from JSON with enhanced error handling
  factory ExpenseModel.fromJson(Map<String, dynamic> json) {
    try {
      // Handle participants from joined query
      final participantsData =
          json['expense_participants'] as List<dynamic>? ?? [];
      final participants = participantsData
          .map(
            (participantJson) => ExpenseParticipantModel.fromJson(
              participantJson as Map<String, dynamic>,
            ),
          )
          .cast<ExpenseParticipant>()
          .toList();

      return ExpenseModel(
        id: json['id'] as String,
        groupId: json['group_id'] as String,
        payerId: json['payer_id'] as String,
        payerName: json['payer_name'] as String,
        amount: (json['amount'] as num).toDouble(),
        currency: json['currency'] as String,
        description: json['description'] as String,
        category: json['category'] as String?,
        expenseDate: DateTime.parse(json['expense_date'] as String),
        participants: participants,
        createdAt: DateTime.parse(json['created_at'] as String),
        updatedAt: DateTime.parse(json['updated_at'] as String),
      );
    } catch (e) {
      throw FormatException('Failed to parse ExpenseModel from JSON: $e');
    }
  }

  /// Create a new expense for insertion with current timestamp
  factory ExpenseModel.create({
    required String groupId,
    required String payerId,
    required String payerName,
    required double amount,
    required String currency,
    required String description,
    required DateTime expenseDate,
    required List<ExpenseParticipant> participants,
  }) {
    final now = DateTime.now();
    return ExpenseModel(
      id: '', // Will be generated by database
      groupId: groupId,
      payerId: payerId,
      payerName: payerName,
      amount: amount,
      currency: currency,
      description: description,
      expenseDate: expenseDate,
      participants: participants,
      createdAt: now,
      updatedAt: now,
    );
  }

  /// Create from domain entity
  factory ExpenseModel.fromEntity(Expense entity) {
    return ExpenseModel(
      id: entity.id,
      groupId: entity.groupId,
      payerId: entity.payerId,
      payerName: entity.payerName,
      amount: entity.amount,
      currency: entity.currency,
      description: entity.description,
      category: entity.category,
      expenseDate: entity.expenseDate,
      participants: entity.participants,
      createdAt: entity.createdAt,
      updatedAt: entity.updatedAt,
    );
  }

  /// Convert to domain entity
  Expense toEntity() {
    return Expense(
      id: id,
      groupId: groupId,
      payerId: payerId,
      payerName: payerName,
      amount: amount,
      currency: currency,
      description: description,
      category: category,
      expenseDate: expenseDate,
      participants: participants,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }

  /// Convert to JSON for database operations
  @override
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'group_id': groupId,
      'payer_id': payerId,
      'payer_name': payerName,
      'amount': amount,
      'currency': currency,
      'description': description,
      'category': category,
      'expense_date': expenseDate.toIso8601String(),
      'created_at': createdAt.toIso8601String(),
      'updated_at': updatedAt.toIso8601String(),
    };
  }

  /// Create JSON for database insertion
  /// (without id and timestamps for auto-generation)
  Map<String, dynamic> toInsertJson() {
    return {
      'group_id': groupId,
      'payer_id': payerId,
      'payer_name': payerName,
      'amount': amount,
      'currency': currency,
      'description': description,
      'category': category,
      'expense_date': expenseDate.toIso8601String(),
    };
  }

  /// Create JSON for database update (only updatable fields)
  Map<String, dynamic> toUpdateJson() {
    return {
      'payer_id': payerId,
      'payer_name': payerName,
      'amount': amount,
      'currency': currency,
      'description': description,
      'category': category,
      'expense_date': expenseDate.toIso8601String(),
      'updated_at': DateTime.now().toIso8601String(),
    };
  }

  /// Create a copy with updated fields
  @override
  ExpenseModel copyWith({
    String? id,
    String? groupId,
    String? payerId,
    String? payerName,
    double? amount,
    String? currency,
    String? description,
    String? category,
    DateTime? expenseDate,
    List<ExpenseParticipant>? participants,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return ExpenseModel(
      id: id ?? this.id,
      groupId: groupId ?? this.groupId,
      payerId: payerId ?? this.payerId,
      payerName: payerName ?? this.payerName,
      amount: amount ?? this.amount,
      currency: currency ?? this.currency,
      description: description ?? this.description,
      category: category ?? this.category,
      expenseDate: expenseDate ?? this.expenseDate,
      participants: participants ?? this.participants,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  /// Update the expense with new timestamp
  ExpenseModel update({
    String? payerId,
    String? payerName,
    double? amount,
    String? currency,
    String? description,
    String? category,
    DateTime? expenseDate,
    List<ExpenseParticipant>? participants,
  }) {
    return copyWith(
      payerId: payerId ?? this.payerId,
      payerName: payerName ?? this.payerName,
      amount: amount ?? this.amount,
      currency: currency ?? this.currency,
      description: description ?? this.description,
      category: category ?? this.category,
      expenseDate: expenseDate ?? this.expenseDate,
      participants: participants ?? this.participants,
      updatedAt: DateTime.now(),
    );
  }
}
